package f_OOP2;

public class OOP2_Basic {
	public static void main(String[] args) {
		/*
		1. 상속 (~은 ~이다.) : is a - 인간은 포유류이다.
		  - 기존의 클래스를 재사용하여 새로운 클래스를 만든다.
		  - 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		  - 새로 작성하고자 하는 클래스의 뒤에 상속 받고자 하는 클래스를 키워드 'extends'와 함께 써주기만 하면 된다.
		  
		    class Child extends Parent{
		    
		    }
		    
		  - 상속을 해주는 클래스를 '조상클래스', 상속을 받는 클래스를 '자손클래스'
		    : 조상클래스 - 상위클래스, 부모클래스, 기반클래스
		    : 자손클래스 - 하위클래스, 자식클래스, 파생된클래스
		    
		  - 상속을 받을때는 멤버만 상속받는다.
		  - 항상 자손클래스가 부모클래스보다 같거나 크다.
		  
		    
		2. 포함 (~은 ~을 포함하고 있다.) : has a - 원은 점을 포함한다
		  - 상속 이외에 클래스를 재사용하는 방법
		  - 클래스의 멤버변수로 다른클래스를 선언하는 방법
		  - 우리가 쓰는 게 대부분 '포함'
		
		3. toString()
		  - 인스턴스의 정보를 제공할 목적으로 사용된다.
		  - 참조변수를 출력하면 참조변수가 가르키고 있는 인스턴스의 toString()를 호출한다.
		  Tv t = new Tv();
		  System.out.println(t.toString());
		  
		4. 단일상속
		  - 자바에서는 단일상속(두개이상불가)만 가능하다.
		  - class TVCR extends Tv, VCR{ // 허용하지않는다
		  
		  	}
		  - Tv와 VCR에 동일한 메소드가 존재한다면 어떤 메서드를 상속받는 지 알 수 없다.
		  - Tv의 메서드명을 변경한다면 그동안 사용해온 모든 곳을 수정해주어야 한다.
		  - 클래스 간의 관계가 명확해진다.
		
		5. Object클래스(모든 클래스의 조상 = 최상위 클래스)
		  - 다른 클래스를 상속받지 않는 클래스는 Object클래스를 상속 받는다.
		    class A extends Object{
		    	
		    }
		
		  - 모든 클래스는 Object클래스를 상속받게 되어 있다.
		  - toString()나 equals()를 사용할 수 있는 것은 Object클래스의 메서드이기 때문이다.
		
		6. 오버라이딩(overriding)
		  - (*오버로딩: 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것, 매개변수 타입과 갯수가 중요)
		  - 조상클래스로부터 상속받은 메서드의 '내용'을 '재정의'하는 것. (선언부는 똑같이, 구현부는 내가 원하는대로)
		  - 오버라이딩이 되기 위한 조건 (선언부가 동일하면 된다.)
		  	: 메서드명이 동일해야 한다.
		  	: 매개변수의 갯수와 타입이 같아야 한다.
		  	: 반환타입이 같아야 한다.
		  	
		  - 부모클래스로부터 상속받는 자손클래스의
		    : 접근제어자는 부모보다 좁은 범위를 설정할 수 없다.
		    : 예외의 갯수는 부모클래스의 메서드가 가진 예외보다 많이 선언할 수 없다.
		  
		    제어자 void method() 예외처리 {
		  
		  }
		  
		7. super.
		  - 조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 있을 때 구분할 목적으로 사용된다. (멤버 = 변수+메서드)
		  - 조상의 멤버와 자손의 멤버를 구분한다는 점을 제외하고는 this.과 동일하다.
		  
		8. super() - 조상클래스의 생성자
		  - this()와 마찬가지로 super()도 생성자 호출이다.
		  - this(): 같은 클래스의 생성자 내에서 다른 생성자를 호출할 때 사용한다.
		  - super(): 자손클래스의 생성자 내에서 부모클래스의 생성자를 호출할 때 사용한다.
		  - 맨위에올려줘야되기때문에 둘다같이는 못쓰지만 일반적으로 super()가 올라가있다.
		  
		9. 제어자(p.144~148)
		  - 변수, 메서드 그리고 클래스의 선언부에 사용이 된다.
		  - 접근제어자와 그 외 제어자로 나누어 진다.
		  - 접근제어자 - 오직 1개만
		    : public, protected, default, private
		  - 그 외 제어자 - 여러개 가능
		    : static, final, abstract, native, ....
		  - 일반적으로 접근제어자를 가장 왼쪽에 써준다.
		    : private static final int a;
		    
		9-1. 그 외 제어자(p.144~146)
		  - static (클래스의, 공통적인)
		    : 모든 인스턴스가 공통으로 사용하는 녀석 
		    : 변수, 메서드, 초기화블럭에 사용할 수 있다.
		    : 변수나 메서드에 사용시 
		      1) 모든 인스턴스에서 공통적으로 사용
		      2) 인스턴스의 생성없이 사용할 수 있다.
		      3) 클래스가 Method Area에 로드될때 같이 생성된다.
		      4) 클래스 멤버에서는 인스턴스 멤버를 호출할 수 없다.
		      
		  - final (마지막의, 변경될 수 없는)
		    : 변수에 사용시, 값을 변경할 수 없는 상수가 된다.
		    : 메서드에 사용시, 오버라이드할 수 없는 메서드가 된다. (= 수정해서 못 쓴다)
		    : 클래스에 사용시, 상속할 수 없는 클래스가 된다. (=부모 클래스가 될 수 없다) - 생성자가 private인 경우
		    
		  - abstract (추상의, 미완성의)
		    : 메서드와 클래스에만 사용이 가능하다.
		    : 메서드는 선언부와 구현부로 되어있지만 추상메서드는 선언부만 존재
		      - 추상 메서드 (물끓이는 기능은 있는데 어떻게 끓이는지는 안나와있음)
		    : 추상메서드를 한 개라도 가지고 있으면 해당 클래스는 추상클래스가 되어야한다 (*클래스는 뭉텅이, 선언부+구현부 아님)
		    
		    abstract class A{
		    	abstract void method();
		    }
		   
		9-2. 접근제어자(p.146~148) - ProTest_01.java , ProTest_02.java, ProTest_03.java(z_exam)
		  - public
		    : 접근제한이 없다
		  - protected ★
		    : 같은 패키지 + 다른 패키지에 있는 클래스의 자손클래스에서 사용가능
		    : 클래스에는 사용불가 ★ : 상속이 먼저 이루어져야 쓸 수 있는데 protected class는 상속자체가 안되니깐
		  - default
		    : 같은 패키지 내에서만 사용가능
		  - private
		    : 같은 클래스 내에서만 사용가능
		    : 클래스에는 사용 불가 ★ (클래스는 다른 곳에서 쓰려고 만드는 것이기때문)
		    
		10. 캡슐화 (p.149~150) - TimeTest.java
		  - 접근제어자를 사용하는 이유
		    : 외부로부터 데이터를 보호하기 위해서
		    : 외부에는 불필요한 부분을 감출 수 있다.
		    
		    DTO: Data Table Object
		    - DB테이블의 변수만 가지고있음
		    - class MemberDTO{
		      	String mem_id; //db 컬럼1개 - java 변수1개 매칭되는 것
		    	String mem_pw;
		    	String mem_name;
		      }
		      
		    VO: Variable Object
		    - 테이블2개조인하면서 필요한컬럼속속속빼서 유동적으로 만든 테이블은 VO
		    - class MemberCartVO{
		    
		      }
		      
		 11. 생성자의 접근제어자 
		   - 인스턴스의 생성을 제한
		   - 생성자의 접근제어자를 private으로 할 경우
		     : 외부에서는 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없다.
		     : 다른 클래스의 조상이 될 수없다. 그러므로 final을 붙여 주어야 한다.
		     
		   (받아적은 것) - SingletonTest.java
		   - 지금까지는 필요할때마다 객체를 만들었지만 이제는 객체 생성에 제한을 둘 것임.
		   - 디자인패턴 - 싱글톤패턴
		     : 특정 클래스의 객체가 오직 한 개만 존재하도록 보장한다. 즉 클래스의 객체를 하나로 제한한다.
		     : 고급자바부터 100% 적용됨
		     : 가장 많이 쓰이는 패턴
		     : 프로그램실행 -> 클래스 전부 로드 -> 객체 전부 생성해서 바로 사용  (실행 속도는 빠르나 처음 로드시 오래걸림)
		   - 그동안은 default로 했지만 이제 private할거야.. -> 객체생성 불가능
		     -> 그럼 객체를 얻어올 수 있는 메소드를 만들어서 써야겠지....
		     
		12. 다형성(Polymorphism) - ★★★
		  - 여러가지 형태를 가질 수 있는 성질
		  - 참조변수의 형변환이나 다름없음. 상속관계에 있을 때만 가능
		  - 부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		   
		13. 참조변수의 형변환
		  - 상속관계에서만 가능하다.
		  - 자식타입 -> 부모타입 : up-casting, 	캐스트연산자 생략 가능
		  - 부모타입 -> 자식타입 : down-casting, 캐스트연산자 생략 불가
		 
		14. instanceof 연산자 (p.155-156) - InstanceTest
		  - 참조변수가 참조하고 있는 인스턴스의 실제타입을 알아보기 위해 사용한다.
		  - 다운캐스팅된거면 이게 누구 객첸지 모르니까 사용함
		  - 연산결과가 true이면 검사한 타입으로 형변환이 가능하다.
		  - 클래스멤버는 참조변수의 타입에 영향을 받는다. ★★
		  - 참조변수의 타입에 영향을 받지 않는 것은 인스턴스메서드 뿐이다. ★★
		   
		15. 매개변수의 다형성 (p.157) - ProductTest.java
		  - 참조변수의 다형적인 특징은 매개변수에도 적용된다.
		   
		16. 여러객체배열, Vector (p.157~8, 200~201) - ProductTest.java
		  - 배열은 한번 크기를 정하면 변경할 수 없다. 이를 해결하기위해 만들어졌다.
		  - Vector 동적으로 크기가 관리되는 객체배열이다.
		    : Vector() -> 10개의 객체를 저장할 수 있는 Vector객체를 만든다.
		    : add()    -> Vector에 객체를 추가한다.  - 매개변수 1개짜리 2개짜리?
		    : remove() -> Vector에서 객체를 삭제한다.
		    : isEmpty()-> Vector가 비어있는지 확인한다.
		    : get(int index) -> index번째 객체를 가져온다.
		    : size() -> 저장된 객체의 개수를 반환한다. 
		 		   
		17. 추상클래스(abstract)
			- 미완성된 클래스
				: 미완성된 메서드를 포함하고 있다.
			- 추상메서드
				: 미완성된 메서드이다.
				: 메서드는 선언부와 구현부로 이루어져 있지만 추상메서드는 구현부가 없다.
		    - 어떤 기능을 수행할 목적으로 만든것인지?
		    
		18. 인터페이스(interface)
			- 일종의 추상클래스이지만 멤버변수로 상수와 추상메서드만 가진다
			- 작성방법
				interface 인터페이스명 {
					[public static final] 변수타입 변수명 = 값;		<- 상수
					[public abstract] 반환타입 메서드명(매개변수); 	<- 추상메서드('{ }' 사용 x) 
				}
			- 모든 변수는 public static final이어야 한다.(생략가능)
			- 모든 메서드는 public abstract이어야 한다.(생략가능)
			
			- 인터페이스 상속
				: 인터페이스는 클래스를 상속할 수 없다.
					-> 클래스를 상속받으면 인터페이스가 아니게 된다.
				: 인테페이스는 인터페이스를 다중 상속할 수 있다.
			
			- 인터페이스 구현
				: 인터페이스 자체로는 객체를 생성할 수 없다.
				: 자신의 정의된 추상메서드의 몸통을 만들어주는 클래스가 존재해야 한다.
				: 상속 => extends, 구현 => implements
				: 인터페이스의 일부분만 구현하였다면 해당 클래스는 추상클래스가 된다.
				: ~을 할 수 있는(~able) 의미를 가진다.
				: IMember => IMemberImpl
				
			- 인터페이스의 장점
				: 개발시간을 단축 시킬 수 있다.
				: 표준화가 가능하다.
				: 서로 관계가 없는 클래스들에게 관계를 설정해줄 수 있다.
				: 독립적인 프로그래밍이 가능하다.
				
			- 인터페이스의 이해
				: 클래스를 사용한 쪽(user)과 제공하는 쪽(provier)로 나눈다.
				: 메서드를 사용하는 쪽에서는 선언부만 알면 된다.
					-> A - I - B (직접 관계에서 interface를 추가해 간접적인 관계로 만들어준다)
				
		
			
		*/
		
	}
}
